/**
 * ai_engine.js - B·ªô n√£o x·ª≠ l√Ω logic cho Tr·ª£ l√Ω AI
 * Phi√™n b·∫£n: 6.0 (T√≠ch h·ª£p Tr√≠ Tu·ªá Ch·∫©n ƒêo√°n S·ª± C·ªë)
 */

// Bi·∫øn to√†n c·ª•c ƒë·ªÉ l∆∞u tr·ªØ d·ªØ li·ªáu v√† tr·∫°ng th√°i
let allPcComponents = [];
let allServicesData = []; // M·ªöI: L∆∞u tr·ªØ d·ªØ li·ªáu d·ªãch v·ª•
let conversationState = {};
let currentBuild = [];
let recommendedServices = []; // M·ªöI: L∆∞u c√°c d·ªãch v·ª• ƒë∆∞·ª£c ƒë·ªÅ xu·∫•t

// H√†m kh·ªüi t·∫°o, ƒë∆∞·ª£c g·ªçi t·ª´ script.js
function initializeAIAssistant(components, services) {
    allPcComponents = components;
    allServicesData = services; // M·ªöI: Nh·∫≠n d·ªØ li·ªáu d·ªãch v·ª•

    const aiBtn = document.getElementById('ai-assistant-btn');
    const aiModal = document.getElementById('ai-modal');
    const closeAiModalBtn = document.getElementById('close-ai-modal-btn');
    const aiModalContent = document.querySelector('.ai-modal-content');

    // G·∫Øn c√°c listener c·ªë ƒë·ªãnh
    aiBtn?.addEventListener('click', startConversation);
    closeAiModalBtn?.addEventListener('click', endConversation);
    aiModal?.addEventListener('click', (e) => {
        if (e.target === aiModal) endConversation();
    });

    // H·ªá Th·ªëng Gi√°m S√°t S·ª± Ki·ªán Trung T√¢m
    aiModalContent?.addEventListener('click', (e) => {
        const button = e.target.closest('.ai-option-btn');
        if (button && !button.disabled) {
            const text = button.textContent.trim();
            const action = button.dataset.action;
            const data = button.dataset.data ? JSON.parse(button.dataset.data) : {};
            handleOptionClick(text, action, data);
        }
    });
}

// B·∫Øt ƒë·∫ßu cu·ªôc tr√≤ chuy·ªán
function startConversation() {
    document.getElementById('ai-modal')?.classList.add('visible');
    document.getElementById('ai-chat-log').innerHTML = '';
    conversationState = { step: 'start' };
    currentBuild = [];
    recommendedServices = [];

    appendMessage('ai', "Ch√†o b·∫°n, t√¥i l√† Tr·ª£ l√Ω AI c·ªßa Minh ƒêƒÉng IT. T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n h√¥m nay?");
    showOptions([
        { text: 'T∆∞ v·∫•n l·∫Øp m√°y m·ªõi', action: 'startBuildPc' },
        { text: 'M√°y c·ªßa t√¥i g·∫∑p s·ª± c·ªë', action: 'startDiagnose' }, // N√ÇNG C·∫§P
        { text: 'T√¨m d·ªãch v·ª• kh√°c', action: 'findService' }
    ]);
}

// K·∫øt th√∫c cu·ªôc tr√≤ chuy·ªán
function endConversation() {
    document.getElementById('ai-modal')?.classList.remove('visible');
}

// Hi·ªÉn th·ªã tin nh·∫Øn trong chat log
function appendMessage(sender, text, contentHtml = '') {
    const chatLog = document.getElementById('ai-chat-log');
    const messageDiv = document.createElement('div');
    if (sender === 'ai') {
        messageDiv.className = 'ai-message';
        messageDiv.innerHTML = `<div class="ai-avatar">ü§ñ</div><div class="ai-bubble"><p>${text}</p>${contentHtml}</div>`;
    } else {
        messageDiv.className = 'user-message';
        messageDiv.innerHTML = `<div class="user-bubble">${text}</div>`;
    }
    chatLog.appendChild(messageDiv);
    chatLog.scrollTop = chatLog.scrollHeight;
}

// Hi·ªÉn th·ªã c√°c n√∫t l·ª±a ch·ªçn
function showOptions(options) {
    const optionsContainer = document.getElementById('ai-options-container');
    optionsContainer.innerHTML = '';
    options.forEach(option => {
        const button = document.createElement('button');
        button.className = 'ai-option-btn';
        button.textContent = option.text;
        button.dataset.action = option.action;
        if (option.data) {
            button.dataset.data = JSON.stringify(option.data);
        }
        optionsContainer.appendChild(button);
    });
}

// X·ª≠ l√Ω khi ng∆∞·ªùi d√πng ch·ªçn m·ªôt option
function handleOptionClick(text, action, data = {}) {
    if(!['changeComponent', 'selectNewComponent', 'redisplayBuild'].includes(action)) {
        appendMessage('user', text);
    }
    document.getElementById('ai-options-container').innerHTML = '';

    setTimeout(() => {
        switch (action) {
            // Lu·ªìng Build PC
            case 'startBuildPc': promptForBudget(); break;
            case 'setBudget': conversationState.budget = data; promptForPurpose(data.key); break;
            case 'setPurpose': conversationState.purpose = data; processBuildConfig(); break;
            case 'addToCart': addBuildToCart(); break;
            case 'changeComponent': promptForComponentChange(data.type); break;
            case 'selectNewComponent': updateComponent(data.newComponent); break;
            case 'redisplayBuild': redisplayCurrentBuild(); break;
            
            // N√ÇNG C·∫§P: Lu·ªìng Ch·∫©n ƒêo√°n
            case 'startDiagnose': promptForSymptom(); break;
            case 'setSymptom': processDiagnosis(data.symptom); break;
            case 'addServicesToCart': addRecommendedServicesToCart(); break;

            // Lu·ªìng Chung
            case 'findService':
                 appendMessage('ai', "B·∫°n c√≥ th·ªÉ tham kh·∫£o c√°c d·ªãch v·ª• ch√≠nh c·ªßa ch√∫ng t√¥i tr√™n trang web, ho·∫∑c cho t√¥i bi·∫øt v·∫•n ƒë·ªÅ b·∫°n ƒëang g·∫∑p ph·∫£i ƒë·ªÉ ƒë∆∞·ª£c t∆∞ v·∫•n ch√≠nh x√°c h∆°n nh√©.");
                 showOptions([{ text: 'B·∫Øt ƒë·∫ßu l·∫°i', action: 'restart' }]);
                break;
            case 'restart': startConversation(); break;
        }
    }, 500);
}

// --- LU·ªíNG CH·∫®N ƒêO√ÅN S·ª∞ C·ªê ---
function promptForSymptom() {
    appendMessage('ai', "T√¥i hi·ªÉu r·ªìi. Xin h√£y m√¥ t·∫£ r√µ h∆°n v·ªÅ tri·ªáu ch·ª©ng m√† m√°y t√≠nh c·ªßa b·∫°n ƒëang g·∫∑p ph·∫£i:");
    showOptions([
        { text: 'M√°y ch·∫°y r·∫•t ch·∫≠m, gi·∫≠t lag', action: 'setSymptom', data: { symptom: 'slow' } },
        { text: 'Kh√¥ng l√™n ngu·ªìn / kh√¥ng l√™n h√¨nh', action: 'setSymptom', data: { symptom: 'no_power' } },
        { text: 'L·ªói m√†n h√¨nh xanh (BSOD)', action: 'setSymptom', data: { symptom: 'bsod' } },
        { text: 'Nhi·ªÖm virus, hi·ªán nhi·ªÅu qu·∫£ng c√°o l·∫°', action: 'setSymptom', data: { symptom: 'virus' } },
        { text: 'V·∫•n ƒë·ªÅ kh√°c', action: 'setSymptom', data: { symptom: 'other' } }
    ]);
}

function processDiagnosis(symptom) {
    appendMessage('ai', "D·ª±a tr√™n m√¥ t·∫£ c·ªßa b·∫°n, t√¥i ƒëang ph√¢n t√≠ch c√°c gi·∫£i ph√°p ph√π h·ª£p...");
    
    let diagnosisText = "";
    let serviceIds = [];

    switch(symptom) {
        case 'slow':
            diagnosisText = "M√°y ch·∫°y ch·∫≠m th∆∞·ªùng do nhi·ªÅu nguy√™n nh√¢n nh∆∞ ƒë·∫ßy ·ªï c·ª©ng, ph·∫ßn m·ªÅm r√°c, ho·∫∑c linh ki·ªán xu·ªëng c·∫•p. Gi·∫£i ph√°p t·ªët nh·∫•t l√† b·∫£o tr√¨ to√†n di·ªán v√† c√¢n nh·∫Øc n√¢ng c·∫•p ·ªï c·ª©ng SSD.";
            serviceIds = ['scpc01', 'scpc02'];
            break;
        case 'no_power':
            diagnosisText = "L·ªói kh√¥ng l√™n ngu·ªìn/h√¨nh l√† m·ªôt s·ª± c·ªë nghi√™m tr·ªçng, c√≥ th·ªÉ do ngu·ªìn, RAM, ho·∫∑c bo m·∫°ch ch·ªß. C·∫ßn ph·∫£i ki·ªÉm tra ph·∫ßn c·ª©ng chuy√™n s√¢u ƒë·ªÉ x√°c ƒë·ªãnh ch√≠nh x√°c.";
            serviceIds = ['scpc02']; // D·ªãch v·ª• ki·ªÉm tra, n√¢ng c·∫•p/thay th·∫ø
            break;
        case 'bsod':
            diagnosisText = "L·ªói m√†n h√¨nh xanh th∆∞·ªùng li√™n quan ƒë·∫øn l·ªói ph·∫ßn m·ªÅm, driver kh√¥ng t∆∞∆°ng th√≠ch ho·∫∑c l·ªói RAM. C·∫ßn ki·ªÉm tra v√† c√†i ƒë·∫∑t l·∫°i h·ªá ƒëi·ªÅu h√†nh ƒë·ªÉ ƒë·∫£m b·∫£o ·ªïn ƒë·ªãnh.";
            serviceIds = ['scpc03'];
            break;
        case 'virus':
            diagnosisText = "Vi·ªác nhi·ªÖm virus v√† ph·∫ßn m·ªÅm qu·∫£ng c√°o kh√¥ng ch·ªâ g√¢y phi·ªÅn to√°i m√† c√≤n ti·ªÅm ·∫©n nguy c∆° m·∫•t d·ªØ li·ªáu. C·∫ßn ph·∫£i qu√©t v√† di·ªát virus b·∫±ng c√¥ng c·ª• chuy√™n d·ª•ng.";
            serviceIds = ['anm02', 'scpc03'];
            break;
        case 'other':
            diagnosisText = "V·ªõi c√°c v·∫•n ƒë·ªÅ ph·ª©c t·∫°p, c√°ch t·ªët nh·∫•t l√† mang m√°y ƒë·∫øn ƒë·ªÉ ƒë∆∞·ª£c ki·ªÉm tra tr·ª±c ti·∫øp. Ch√∫ng t√¥i s·∫Ω ch·∫©n ƒëo√°n ch√≠nh x√°c v√† ƒë∆∞a ra gi·∫£i ph√°p t·ªëi ∆∞u cho b·∫°n.";
            serviceIds = []; // Kh√¥ng ƒë·ªÅ xu·∫•t d·ªãch v·ª• c·ª• th·ªÉ
            break;
    }
    
    // T√¨m c√°c d·ªãch v·ª• ƒë·∫ßy ƒë·ªß t·ª´ ID
    const allSubServices = allServicesData.flatMap(s => s.subServices);
    recommendedServices = serviceIds.map(id => allSubServices.find(sub => sub.subId === id)).filter(Boolean);

    setTimeout(() => {
        appendMessage('ai', diagnosisText);
        if (recommendedServices.length > 0) {
            displayServiceRecommendations(recommendedServices);
            showOptions([
                { text: 'Th√™m d·ªãch v·ª• v√†o Y√™u C·∫ßu', action: 'addServicesToCart' },
                { text: 'B·∫Øt ƒë·∫ßu l·∫°i', action: 'restart' }
            ]);
        } else {
            appendMessage('ai', "B·∫°n c√≥ th·ªÉ li√™n h·ªá tr·ª±c ti·∫øp qua SƒêT ho·∫∑c Zalo ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£ nhanh nh·∫•t nh√©!");
            showOptions([{ text: 'B·∫Øt ƒë·∫ßu l·∫°i', action: 'restart' }]);
        }
    }, 1000);
}

function displayServiceRecommendations(services) {
    const serviceHtml = services.map(item => `
        <div class="build-item-row">
            <img src="${item.images[0] || 'https://placehold.co/100x100/0a0a1a/00ffff?text=Dich+Vu'}" alt="${item.name}" class="build-item-image">
            <div class="build-item-info">
                <span class="build-item-name">${item.name}</span>
            </div>
            <span class="build-item-price">${formatPrice(item.price)}</span>
        </div>`).join('');
    const resultHtml = `
        <div class="ai-result-card">
            <div class="ai-result-header"><h3>D·ªãch V·ª• ƒê·ªÅ Xu·∫•t</h3></div>
            <div class="ai-result-body">${serviceHtml}</div>
        </div>`;
    appendMessage('ai', 'ƒê√¢y l√† c√°c d·ªãch v·ª• ph√π h·ª£p:', resultHtml);
}

function addRecommendedServicesToCart() {
    appendMessage('ai', "ƒê√£ hi·ªÉu, t√¥i ƒëang th√™m c√°c d·ªãch v·ª• v√†o gi·ªè h√†ng c·ªßa b·∫°n...");
    if (typeof addServicesToCartFromAI === 'function' && recommendedServices.length > 0) {
        addServicesToCartFromAI(recommendedServices);
        setTimeout(() => {
            appendMessage('ai', "ƒê√£ th√™m th√†nh c√¥ng! B·∫°n c√≥ th·ªÉ nh·∫•n v√†o bi·ªÉu t∆∞·ª£ng gi·ªè h√†ng ƒë·ªÉ xem l·∫°i v√† g·ª≠i y√™u c·∫ßu.");
            showOptions([{ text: 'B·∫Øt ƒë·∫ßu l·∫°i', action: 'restart' }]);
        }, 1000);
    } else {
        appendMessage('ai', "ƒê√£ c√≥ l·ªói x·∫£y ra, vui l√≤ng th·ª≠ l·∫°i.");
    }
}


// --- LU·ªíNG T∆Ø V·∫§N BUILD PC (Kh√¥ng thay ƒë·ªïi) ---
function promptForBudget() {
    appendMessage('ai', "Tuy·ªát v·ªùi! Tr∆∞·ªõc h·∫øt, b·∫°n d·ª± ƒë·ªãnh ƒë·∫ßu t∆∞ kho·∫£ng bao nhi√™u cho b·ªô m√°y m·ªõi n√†y?");
    showOptions([
        { text: 'H·ªçc sinh (< 8 tri·ªáu)', action: 'setBudget', data: { key: 'student-lt-8m', min: 0, max: 8000000 } },
        { text: 'C∆° b·∫£n (8 - 15 tri·ªáu)', action: 'setBudget', data: { key: 'basic-8-15m', min: 8000000, max: 15000000 } },
        { text: 'T·∫ßm trung (15 - 25 tri·ªáu)', action: 'setBudget', data: { key: 'mid-15-25m', min: 15000000, max: 25000000 } },
        { text: 'Cao c·∫•p (25 - 40 tri·ªáu)', action: 'setBudget', data: { key: 'high-25-40m', min: 25000000, max: 40000000 } },
        { text: 'H·∫°ng sang (> 40 tri·ªáu)', action: 'setBudget', data: { key: 'luxury-gt-40m', min: 40000000, max: Infinity } }
    ]);
}
function promptForPurpose(budgetKey) {
    appendMessage('ai', "ƒê√£ hi·ªÉu. B·∫°n s·∫Ω d√πng m√°y ch·ªß y·∫øu cho m·ª•c ƒë√≠ch g√¨?");
    let purposes = [
        { text: 'H·ªçc t·∫≠p & Gi·∫£i tr√≠ nh·∫π', action: 'setPurpose', data: 'study' },
        { text: 'Ch∆°i Game', action: 'setPurpose', data: 'gaming' },
        { text: 'L√†m ƒê·ªì h·ªça / Video', action: 'setPurpose', data: 'workstation' }
    ];
    if (budgetKey === 'student-lt-8m' || budgetKey === 'basic-8-15m') {
        purposes = purposes.filter(p => p.data !== 'workstation');
    }
    showOptions(purposes);
}
function processBuildConfig() {
    appendMessage('ai', "Ok, d·ª±a tr√™n l·ª±a ch·ªçn c·ªßa b·∫°n, t√¥i ƒëang ph√¢n t√≠ch c√°c linh ki·ªán ph√π h·ª£p nh·∫•t. Vui l√≤ng ch·ªù trong gi√¢y l√°t...");
    setTimeout(() => {
        const result = buildPc(conversationState.budget, conversationState.purpose);
        if (result && result.build) {
            currentBuild = result.build;
            displayBuildResult(result.build, result.totalPrice, result.wattage);
            showOptions([{ text: 'Th√™m v√†o Y√™u C·∫ßu', action: 'addToCart' }, { text: 'L√†m l·∫°i t·ª´ ƒë·∫ßu', action: 'restart' }]);
        } else {
            appendMessage('ai', "R·∫•t ti·∫øc, t√¥i kh√¥ng t√¨m th·∫•y c·∫•u h√¨nh n√†o ph√π h·ª£p v·ªõi c√°c ti√™u ch√≠ n√†y. B·∫°n vui l√≤ng th·ª≠ l·∫°i v·ªõi l·ª±a ch·ªçn kh√°c nh√©.");
            showOptions([{ text: 'Ch·ªçn l·∫°i ng√¢n s√°ch', action: 'startBuildPc' }]);
        }
    }, 1000);
}
function findCheapestComponent(type, filterFunc = () => true) { return allPcComponents.filter(c => c.type === type && filterFunc(c)).sort((a, b) => a.price - b.price)[0]; }
function findComponents(type, filterFunc = () => true) { return allPcComponents.filter(c => c.type === type && filterFunc(c)).sort((a, b) => a.price - b.price); }
function buildPc(budget, purpose) {
    let cpu, mainboard, ram, gpu, storage, psu, caseComponent, cooler;
    switch (budget.key) {
        case 'student-lt-8m':
            cpu = findCheapestComponent('cpu', c => c.price < 3500000 && c.name.includes('G'));
            gpu = null;
            mainboard = findCheapestComponent('mainboard', m => m.socket === cpu?.socket && m.ram_type === 'DDR4');
            ram = findCheapestComponent('ram', r => r.ram_type === 'DDR4' && r.name.includes('8GB'));
            storage = findCheapestComponent('storage', s => s.price < 1000000);
            let affordableCase = findCheapestComponent('case', c => c.price < 800000);
            caseComponent = affordableCase ? affordableCase : findCheapestComponent('case');
            cooler = null;
            break;
        case 'basic-8-15m':
            cpu = findCheapestComponent('cpu', c => c.price >= 2500000 && c.price < 4000000);
            mainboard = findCheapestComponent('mainboard', m => m.socket === cpu?.socket && m.ram_type === 'DDR4');
            ram = findCheapestComponent('ram', r => r.ram_type === 'DDR4' && r.name.includes('16GB'));
            gpu = findCheapestComponent('gpu', g => g.price >= 5000000 && g.price < 7000000);
            storage = findCheapestComponent('storage', s => s.name.includes('500GB'));
            caseComponent = findCheapestComponent('case', c => c.price < 1000000);
            cooler = findCheapestComponent('cooler', c => c.price < 500000);
            break;
        case 'mid-15-25m':
            cpu = findCheapestComponent('cpu', c => c.price >= 4000000 && c.price < 6000000);
            mainboard = findCheapestComponent('mainboard', m => m.socket === cpu?.socket);
            ram = findCheapestComponent('ram', r => r.ram_type === mainboard?.ram_type && r.name.includes('16GB'));
            gpu = findCheapestComponent('gpu', g => g.price >= 7000000 && g.price < 13000000);
            storage = findCheapestComponent('storage', s => s.name.includes('1TB'));
            caseComponent = findCheapestComponent('case');
            cooler = findCheapestComponent('cooler', c => c.price < 1000000);
            break;
        case 'high-25-40m':
            cpu = findCheapestComponent('cpu', c => c.price >= 6000000 && c.price < 12000000);
            mainboard = findCheapestComponent('mainboard', m => m.socket === cpu?.socket && m.ram_type === 'DDR5');
            ram = findCheapestComponent('ram', r => r.ram_type === 'DDR5' && r.name.includes('32GB'));
            gpu = findCheapestComponent('gpu', g => g.price >= 13000000 && g.price < 25000000);
            storage = findCheapestComponent('storage', s => s.name.includes('1TB') && s.price > 2000000);
            caseComponent = findCheapestComponent('case', c => c.price > 2000000);
            cooler = findCheapestComponent('cooler', c => c.price > 1000000);
            break;
        case 'luxury-gt-40m':
            cpu = findCheapestComponent('cpu', c => c.price > 12000000);
            mainboard = findCheapestComponent('mainboard', m => m.socket === cpu?.socket && m.ram_type === 'DDR5');
            ram = findCheapestComponent('ram', r => r.ram_type === 'DDR5' && r.name.includes('32GB'));
            gpu = findCheapestComponent('gpu', g => g.price > 25000000);
            storage = findCheapestComponent('storage', s => s.name.includes('2TB'));
            caseComponent = findCheapestComponent('case', c => c.price > 3000000);
            cooler = findCheapestComponent('cooler', c => c.price > 2000000);
            break;
    }
    const essentialComponents = [cpu, mainboard, ram, storage, caseComponent];
    if (cpu && !cpu.name.includes('G') && !gpu) return null; 
    if (essentialComponents.some(c => !c)) return null;
    return calculatePsuAndFinalize([cpu, mainboard, ram, gpu, storage, psu, caseComponent, cooler], budget);
}
function calculatePsuAndFinalize(build, budget) {
    let currentBuild = [...build];
    const wattage = currentBuild.filter(c => c).reduce((sum, item) => sum + (item.wattage || 0), 0);
    const requiredWattage = Math.ceil((wattage * 1.4) / 50) * 50;
    const psu = findCheapestComponent('psu', p => p.wattage >= requiredWattage);
    if (!psu) return null;
    const psuIndex = currentBuild.findIndex(c => c?.type === 'psu');
    if (psuIndex !== -1) { currentBuild[psuIndex] = psu; } else { currentBuild.push(psu); }
    const finalBuild = currentBuild.filter(Boolean);
    const totalPrice = finalBuild.reduce((sum, item) => sum + item.price, 0);
    if (budget.max && totalPrice > budget.max && !(budget.key === 'student-lt-8m' && totalPrice < 8500000)) {
        return null;
    }
    return { build: finalBuild, totalPrice, wattage: requiredWattage };
}
function formatPrice(price) {
    if (isNaN(price)) return price;
    return new Intl.NumberFormat('vi-VN', { style: 'currency', currency: 'VND' }).format(price);
}
function displayBuildResult(build, totalPrice, wattage) {
    const componentToVietnamese = { cpu: 'Vi x·ª≠ l√Ω (CPU)', mainboard: 'Bo m·∫°ch ch·ªß', ram: 'RAM', gpu: 'Card ƒë·ªì h·ªça (VGA)', storage: '·ªî c·ª©ng', psu: 'Ngu·ªìn (PSU)', case: 'V·ªè case', cooler: 'T·∫£n nhi·ªát' };
    const buildHtml = build.map(item => `
        <div class="build-item-row">
            <img src="${item.image}" alt="${item.name}" class="build-item-image">
            <div class="build-item-info">
                <span class="build-item-type">${componentToVietnamese[item.type] || item.type}</span>
                <span class="build-item-name">${item.name}</span>
            </div>
            <span class="build-item-price">${formatPrice(item.price)}</span>
            <button class="ai-option-btn change-btn" data-action="changeComponent" data-data='${JSON.stringify({type: item.type})}'>Thay ƒë·ªïi</button>
        </div>`).join('');
    const resultHtml = `<div class="ai-result-card"><div class="ai-result-header"><h3>C·∫•u H√¨nh ƒê·ªÅ Xu·∫•t</h3><p>D·ª±a tr√™n nhu c·∫ßu c·ªßa b·∫°n, ƒë√¢y l√† c·∫•u h√¨nh t·ªëi ∆∞u nh·∫•t (y√™u c·∫ßu kho·∫£ng ${wattage}W).</p></div><div class="ai-result-body">${buildHtml}</div><div class="ai-result-footer"><span>T·ªîNG C·ªòNG:</span><span>${formatPrice(totalPrice)}</span></div></div>`;
    appendMessage('ai', 'T√¥i ƒë√£ ho√†n t·∫•t c·∫•u h√¨nh cho b·∫°n!', resultHtml);
}
function addBuildToCart() {
    appendMessage('ai', "Tuy·ªát v·ªùi! T√¥i ƒëang th√™m c√°c linh ki·ªán v√†o gi·ªè h√†ng...");
    if (typeof addBuildToCartFromAI === 'function') {
        addBuildToCartFromAI(currentBuild);
    }
    setTimeout(() => {
        appendMessage('ai', "ƒê√£ th√™m th√†nh c√¥ng! B·∫°n c√≥ th·ªÉ nh·∫•n v√†o bi·ªÉu t∆∞·ª£ng gi·ªè h√†ng ƒë·ªÉ xem l·∫°i v√† g·ª≠i y√™u c·∫ßu.");
        showOptions([{ text: 'B·∫Øt ƒë·∫ßu l·∫°i', action: 'restart' }]);
    }, 1000);
}
function promptForComponentChange(type) {
    const componentToVietnamese = { cpu: 'Vi x·ª≠ l√Ω (CPU)', mainboard: 'Bo m·∫°ch ch·ªß', ram: 'RAM', gpu: 'Card ƒë·ªì h·ªça (VGA)', storage: '·ªî c·ª©ng', psu: 'Ngu·ªìn (PSU)', case: 'V·ªè case', cooler: 'T·∫£n nhi·ªát' };
    const currentComponent = currentBuild.find(c => c.type === type);
    const cpu = currentBuild.find(c => c.type === 'cpu');
    const mainboard = currentBuild.find(c => c.type === 'mainboard');
    let filterFunc = () => true;
    if (type === 'mainboard') filterFunc = m => m.socket === cpu?.socket;
    else if (type === 'cpu') filterFunc = c => c.socket === mainboard?.socket;
    else if (type === 'ram') filterFunc = r => r.ram_type === mainboard?.ram_type;
    const availableOptions = findComponents(type, filterFunc);
    const optionsHtml = availableOptions.map(item => `
        <div class="build-item-row ${item.id === currentComponent.id ? 'current' : ''}">
            <img src="${item.image}" alt="${item.name}" class="build-item-image">
            <div class="build-item-info"><span class="build-item-name">${item.name}</span></div>
            <span class="build-item-price">${formatPrice(item.price)}</span>
            <button class="ai-option-btn select-btn" ${item.id === currentComponent.id ? 'disabled' : ''} data-action="selectNewComponent" data-data='${JSON.stringify({ newComponent: item })}'>Ch·ªçn</button>
        </div>`).join('');
    const resultHtml = `<div class="ai-result-card"><div class="ai-result-header"><h3>Ch·ªçn ${componentToVietnamese[type]} thay th·∫ø</h3><p>C√°c l·ª±a ch·ªçn d∆∞·ªõi ƒë√¢y ƒë·ªÅu t∆∞∆°ng th√≠ch.</p></div><div class="ai-result-body">${optionsHtml}</div></div>`;
    appendMessage('ai', `ƒê√¢y l√† c√°c l·ª±a ch·ªçn cho ${componentToVietnamese[type]}:`, resultHtml);
    showOptions([{ text: 'Quay l·∫°i', action: 'redisplayBuild' }]);
}
function updateComponent(newComponent) {
    const index = currentBuild.findIndex(c => c.type === newComponent.type);
    if (index !== -1) {
        currentBuild[index] = newComponent;
        const cpu = currentBuild.find(c => c.type === 'cpu');
        const mainboard = currentBuild.find(c => c.type === 'mainboard');
        if (newComponent.type === 'cpu' && newComponent.socket !== mainboard.socket) {
            const newMainboard = findCheapestComponent('mainboard', m => m.socket === newComponent.socket);
            currentBuild[currentBuild.findIndex(c => c.type === 'mainboard')] = newMainboard;
        }
        if (newComponent.type === 'mainboard') {
             if (newComponent.socket !== cpu.socket) {
                 const newCpu = findCheapestComponent('cpu', c => c.socket === newComponent.socket);
                 currentBuild[currentBuild.findIndex(c => c.type === 'cpu')] = newCpu;
             }
             const ramIndex = currentBuild.findIndex(c => c.type === 'ram');
             if (currentBuild[ramIndex].ram_type !== newComponent.ram_type) {
                 const newRam = findCheapestComponent('ram', r => r.ram_type === newComponent.ram_type);
                 currentBuild[ramIndex] = newRam;
             }
        }
        redisplayCurrentBuild();
    }
}
function redisplayCurrentBuild() {
    const result = calculatePsuAndFinalize(currentBuild, conversationState.budget);
    if (result && result.build) {
        currentBuild = result.build;
        displayBuildResult(result.build, result.totalPrice, result.wattage);
        showOptions([{ text: 'Th√™m v√†o Y√™u C·∫ßu', action: 'addToCart' }, { text: 'L√†m l·∫°i t·ª´ ƒë·∫ßu', action: 'restart' }]);
    } else {
         appendMessage('ai', "R·∫•t ti·∫øc, c·∫•u h√¨nh m·ªõi v∆∞·ª£t qu√° ng√¢n s√°ch c·ªßa b·∫°n ho·∫∑c c√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i.");
         showOptions([{ text: 'L√†m l·∫°i t·ª´ ƒë·∫ßu', action: 'restart' }]);
    }
}

